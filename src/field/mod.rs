//! This module contains the definition of finite fields and their extension fields.

use std::array;

use rand::distributions::{Distribution, Standard};

use super::*;

pub mod extension;
// pub mod gf_101;
// pub mod gf_101_2;
// pub mod gf_17;
pub mod prime;

/// A field is a set of elements on which addition, subtraction, multiplication, and division are
/// defined.
///
/// We restrict to finite fields, which are fields with a finite number of elements.
#[const_trait]
pub trait FiniteField:
  std::fmt::Debug
  + From<u32>
  + Default
  + Sized
  + Copy
  + Clone
  + PartialEq
  + Eq
  + Add<Output = Self>
  + AddAssign
  + Sum
  + Sub<Output = Self>
  + SubAssign
  + Mul<Output = Self>
  + MulAssign
  + Product
  + Div<Output = Self>
  + DivAssign
  + Neg<Output = Self>
  + Rem<Output = Self>
  + Hash
  + 'static {
  /// The order of the field, i.e., the number of elements in the field.
  const ORDER: u32;
  /// The additive identity element.
  const ZERO: Self;
  /// The multiplicative identity element.
  const ONE: Self;
  /// The number two in the field.
  const TWO: Self;
  /// The number negative one in the field (additive inverse of [`FiniteField::ONE`]).
  const NEG_ONE: Self;
  /// The number three in the field.
  const THREE: Self;
  /// Returns a multiplicative generator of the field.
  const GENERATOR: Self;

  /// Gets the multiplicative inverse of the field element (if it exists).
  fn inverse(&self) -> Option<Self>;

  /// Computes the `power`-th power of the field element.
  // fn pow(&self, mut power: u64) -> Self {
  //   let mut current = *self;
  //   let mut product = Self::ONE;

  //   while power > 0 {
  //     if power % 2 == 1 {
  //       product *= current;
  //     }
  //     current = current * current;
  //     power /= 2;
  //   }

  //   product
  // }
  fn pow(self, power: u64) -> Self;

  /// Returns the primitive n-th root of unity in the field.
  ///
  /// ## Notes
  /// In any field of prime order F_p:
  /// - There exists an additive group.
  /// - There exists a multiplicative subgroup generated by a primitive element 'a'.
  ///
  /// According to the Sylow theorems (https://en.wikipedia.org/wiki/Sylow_theorems):
  /// A non-trivial multiplicative subgroup of prime order 'n' exists if and only if
  /// 'p - 1' is divisible by 'n'.
  /// The primitive n-th root of unity 'w' is defined as: w = a^((p - 1) / n),
  /// and the roots of unity are generated by 'w', such that {w^i | i in [0, n - 1]}.
  fn primitive_root_of_unity(n: u32) -> Self {
    let p_minus_one = Self::ORDER - 1;
    assert!(p_minus_one % n == 0, "n must divide p^q - 1");
    let pow = p_minus_one / n;
    Self::GENERATOR.pow(pow as u64)
  }
}

/// algorithm to compute primitive element of field (multiplicative generator)
// pub const fn get_generator<const P: u32>() -> i32 {
//   let mut fact = Vec::new();
//   let phi = P - 1;
//   let mut n = phi;
//   let mut i = 2;
//   while i * i <= n {
//     if n % i == 0 {
//       fact.push(i);
//       while n % i == 0 {
//         n /= i;
//       }
//     }
//     i += 1;
//   }
//   if n > 1 {
//     fact.push(n);
//   }

//   for res in 2..=P {
//     let mut ok = true;
//     for &f in &fact {
//       ok &= powmod(res, phi / f, P) != 1;
//       if !ok {
//         break;
//       }
//     }
//     if ok {
//       return res as i32;
//     }
//   }
//   -1
// }

const fn powmod(base: u32, exponent: u32, modulus: u32) -> u32 {
  let mut base = base as u64;
  let mut exponent = exponent;
  let modulus = modulus as u64;
  let mut result = 1;
  base %= modulus;
  while exponent > 0 {
    if exponent % 2 == 1 {
      result = (result * base) % modulus;
    }
    base = (base * base) % modulus;
    exponent >>= 1;
  }
  result as u32
}
